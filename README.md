# Just Buffers

You've tried the rest, now try the ~~best!~~ pretty darn good,
and simple, too.

## What are Just Buffers?

Just Buffers are just ... buffers. Or, more precisely, they are "C"
structs. These are the same structs that you might write yourself
to hold your data, except that they are generated for you from a
simple JSON specification. This lets python and other programs to
read in that spec without having to be able to make sense of a header
directly. This, in turn, allows for a few good things to happen:

* you get automatic Python support for encoding and decoding
* you get clear indications where alignment rules have created gaps
  (and by default, those gaps are filled with named placeholders
  that you can fill later when you realize you forgot something!)
* you only have to specify them in one file, and everything comes
  from that.

The philosophy of Just Buffers is simple: the C struct has primacy.
It is kept simple and straighforward, so that from C using them is
basically frictionnless and without overhead. Furthermore, the C
struct is the storage form and the use form. You don't do conversions
in C, to encode to and from. At the same time, Python has easy functions
to encode and decode. This puts the hard work where it is easy.

## What about [protobuf](https://protobuf.dev/) / [nanopb](https://github.com/nanopb/nanopb) / [Cap'nProto](https://capnproto.org/) / [FlatBuffers](https://flatbuffers.dev/) / [JSON](https://www.json.org/json-en.html) / ...

All of those are wonderful tools, and you certainly won't get fired
for using them in your project, but I created Just Buffers because
I found those tools to be fussier than I needed or wanted for most
applications. They solved more problems (like validation) than I needed,
and they came at a cost: special compilers, compilation steps, their
own languages and rules, deps, etc.

On the other hand, Just Buffers is implemented in simple Python with _NO_
extra dependencies whatsoever. This means that no matter your system
and configuration and whatever else you've got going on, if you have
Python3 running at all, you can use Just Buffers.

## How does it work?

The Just Buffers python module reads a simple specification,
usually as JSON, and can immediately be used to encode and decode
buffers. Just instantiate a `JustBufferator()` object. From there,
you can call, encode, decode, or member function that generates
a header for you. There is also a command-line tool called `jb.py`.

For example, let's say we have the following specification in a file called `spec.json`:

```json
{
    "t0_t": [
        { "type": "u32", "name": "fee" },
        { "type": "u16", "name": "fi" },
        { "type": "u64", "name": "fo" },
        { "type": "u8",  "name": "fum", "counts": 128 }
    ],
    "t1_t": [
        { "type": "t0_t", "name": "t0s", "counts": [2,2] },
        { "type": "u16", "name": "blee" }
    ]
}
```

You could run:

```sh
$ ./jb.py -c spec.json --generate-c structs.h
```

That would create a file like this one:
```c
#pragma once
/* 
   This file was generated by ./command.py at 2024-12-11T03:02:03.701712
   * DO NOT EDIT *
*/

#include <stdint.h>
#include <stdbool.h>
#ifndef STATIC_ASSERT
   #define STATIC_ASSERT(test) typedef char assertion_on_struct[(!!(test))*2-1]
#endif
    
typedef struct  t0_t {
  uint32_t             fee;                 // offset 0x0, align 0x4, size 0x4
  uint16_t             fi;                  // offset 0x4, align 0x2, size 0x2
  uint8_t              __pad_0[2];          // offset 0x6, align 0x1, size 0x2
  uint64_t             fo;                  // offset 0x8, align 0x8, size 0x8
  uint8_t              fum[128];            // offset 0x10, align 0x1, size 0x80
} t0;

STATIC_ASSERT(sizeof(t0) == 0x90);

typedef struct  t1_t {
  t0_t                 t0s[2][2];           // offset 0x0, align 0x8, size 0x240
  uint16_t             blee;                // offset 0x240, align 0x2, size 0x2
  uint8_t              __pad_0[6];          // offset 0x242, align 0x1, size 0x6
} t1;

STATIC_ASSERT(sizeof(t1) == 0x248);
```

The asserts in this header are there as a check that the C compiler and
Just Buffers agree about the layout. If they fail, it means there is a 
bug in Just Buffers. Let me know!

Anyway, you can use this header and its structs in your program and you could,
save them to a file or write them to a socket or whatever. Perhaps, something
like this:

```c
#include <stdio.h>
#include <stlib.h>
#include "struct.h"

int main(int argc, char *argv[]) {
    t1_t t = {};

    // do whatever with t
    FILE *f = fopen("bloop.bin", "wb");
    fwrite(&t, 1, sizeof(t), f);
    fclose(f);
    return 0;
}
```

Later on, in python you could do:
```python

import jb.justbuffers as jb

j = jb.JustBufferator(json.loads(open('types.json','r').read()))
decoded = j.decodeBuffer('t1_t', open('bloop.bin','rb').read())
```

Anyway, that's pretty much the gist.

## Portability

### Endianness

I made a decision not to try to manage endianness in Just Buffers.
Most modern machines are little-endian, anyway.

By default, therefore, the python code expects little-endian, and
the C structs have no mention of endianness at all, so they get whatever
your machine(s) do. There is an option in the python to use BE for
encode/decode, if you need it.

If you need to use Just Buffers in C on machines that are both BE
and LE, then it will be necessary for you to use `ntoa` and `aton`-like
functions when accessing member values.

### Sizes

Just Buffers only uses named-size types. So, instead of `int` we always
specify `int32` or `int8`. In fact, this is the list of supported types:

|name  | size |
|------|------|
|bool  | 1    |
|u8    | 1    |
|i8    | 1    |
|u16   | 2    |
|i16   | 2    |
|u32   | 4    |
|i32   | 4    |
|u64   | 8    |
|i64   | 8    |
|float | 4    |
|double| 8    |

Just buffers allows you to use the types above as well as other Just
Buffers, and do singly or in arrays of arbitrary dimension.
All the member types have explicit sizes using stdint.h, so there is
never any doubt as to their size.

### Strings

Strings as such have the level of support they have in C -- very little.
You can, of course, make a fixed-sized `int8` array and put text data in
it. You can use a null to indicate the end of the string, as is normal in
C or store a length along with it. Variable-length arrays are not supported.

### Alignment

Just Buffers does respect and follow the C alignment rules, so there
should never be any issues with that. If you insist on packed structs,
you can pass a `packed` flag to the `JustBufferator` constructor and 
you'll get packed behavior.

### C++

The header files from `.generateCHeader()` should be compatible
with C++. You can use them as-is.

However, there is a small trick available to you that you will see
in use in the tests in this repo. Namely, you can also call a function
called `.generateCPPHeader()`.

This will create a file defines a class much like the C struct, but
which also includes [nlohmann::json](https://github.com/nlohmann/json)
and the necessary code so that the class has the ability to be 
converted to or from JSON. If this is something you thin is nice, by
all means use it! (Of course, using this does at a dep on `nlohmann::json`.)

## Tests

There are some tests in the `tests/` directory. They can be run by
running the test shell or python scripts.

Just Buffers has no deps, but running the tests does. You'll need
gcc, g++, and nlohmann::json.

