#!/usr/bin/env python3

import datetime
import sys
from .. import util


def gen_prolog():
    return f'''
// This files was generated by: {sys.argv[0]}
//                          at: {datetime.datetime.now().isoformat()}
// *** DO NOT EDIT ***

#pragma once
#include <map>
#include <string>
#include <stdint.h>
#include "nlohmann/json.hpp"

'''


def gen_plain_data_members(typeinfo, t_info):
    os = []
    for m_info in t_info['members']:
        if len(m_info['counts']) > 1 or m_info['counts'][0] > 1:
            a_str = '[' + ']['.join([str(x) for x in m_info['counts']]) + ']'
        else:
            a_str = '';
        name_str = ''.join([m_info['name'], a_str, ';'])
        c_type_name = typeinfo.get(m_info['type'], {'c_type': m_info['type'] })['c_type']
        os.append(f'    {c_type_name:20} {name_str:20} // offset 0x{m_info["offset"]:x}, align 0x{m_info["align"]:x}, size 0x{m_info["size"]:x}')
    os.append('')
    return os

def gen_constructors(t_name):
    return [ f'''
    {t_name}(const nlohmann::json &j) {{ fromJS(j); }};
    {t_name}() {{}};

''']

def gen_toJS(typeinfo, t_info, elaborated):
    os = []
    os.append('    nlohmann::json toJS() const {')
    for m_info in t_info['members']:
        m_name = m_info['name']
        if m_info['type'] in elaborated and not util.is_scalar(m_info):
            counts = m_info['counts']
            ivars = [f"idx{n}" for n in range(len(counts))]
            idx_s = ']['.join(ivars)
            for lidx in range(len(counts)):
                name = f'{m_name}_temp_{lidx}'
                if lidx == 0:
                    m_info['vec_name'] = name
                os.append('  ' * lidx + f'      auto {name} = nlohmann::json::array();')
                os.append(
                    '  ' * lidx
                    + f'      for (size_t {ivars[lidx]}=0; {ivars[lidx]} < {counts[lidx]}; {ivars[lidx]}++) {{'
                )

            for lidx in reversed(range(len(counts))):
                name = f'{m_name}_temp_{lidx}'
                if lidx == len(counts) - 1:
                    os.append('  ' * lidx + f'        {name}.push_back({m_name}[{idx_s}].toJS());')
                else:
                    prev_name = f'{m_name}_temp_{lidx+1}'
                    os.append('  ' * lidx + f'        {name}.push_back({prev_name});')
                    
                os.append('  ' * lidx + '      }')
             

    os.append('      return nlohmann::json {')
    for m_info in t_info['members']:
        m_name = m_info['name']
        if m_info['type'] in elaborated and util.is_scalar(m_info):
            os.append(f'        {{ "{m_name}", {m_name}.toJS() }},')
        elif m_info['type'] in elaborated:
            os.append(f'        {{ "{m_name}", {m_info["vec_name"]} }},')
        else:
            os.append(f'        {{ "{m_name}", {m_name} }},')
    os.append('      };')
    os.append('    }')
    os.append('')
    return os


def gen_fromJS(t_info, elaborated):
    def idx_indent(level):
        return '  ' * level

    os = []
    os.append('    bool fromJS(const nlohmann::json &j) {')
    for m_info in t_info['members']:
        m_name = m_info['name']
        os.append(f'      if (j.contains("{m_name}")) {{')
        if util.is_scalar(m_info):
            if m_info['type'] in elaborated:
                os.append(f'        {m_name}.fromJS(j.at("{m_name}"));')
            else:
                os.append(f'        {m_name} = j.at("{m_name}");')
        else:
            counts = m_info['counts']
            ivars = [f"idx{n}" for n in range(len(counts))]
            for lidx in range(len(counts)):
                ivar = ivars[lidx]
                os.append(
                    idx_indent(lidx)
                    + f'        for (size_t {ivar}=0; {ivar} < {counts[lidx]}; {ivar}++) {{'
                )
                idx_s = ']['.join(ivars)
            if m_info['type'] in elaborated:
                os.append(
                    idx_indent(len(counts))
                    + '        '
                    + f'{m_name}[{idx_s}].fromJS(j.at("{m_name}")[{idx_s}]);'
                )
            else:
                os.append(
                    idx_indent(len(counts))
                    + f'      {m_name}[{idx_s}] = j.at("{m_name}")[{idx_s}];'
                )
            for lidx in range(len(counts)):
                os.append( idx_indent(len(counts) - lidx - 1) + '        }')

        os.append('      }')
    os.append('      return true;')
    os.append('    }')
    os.append('')
    return os


def generate(typeinfo, elaborated, packed=False):
    os = [ gen_prolog() ]
    packed = '__attribute__((packed))' if packed else ''
    for t_name, t_info in elaborated.items():
        os.append(f'class {t_name} {packed} {{')
        os.append('  public:')
        os += gen_plain_data_members(typeinfo, t_info);
        os += gen_constructors(t_name)
        os += gen_toJS(typeinfo, t_info, elaborated)
        os += gen_fromJS(t_info, elaborated)
 
        os.append('};')
        os.append('')
        os.append(f'static_assert(sizeof({t_name}) == 0x{t_info["size"]:x}, "sizeof {t_name} not what justbuffers expected; this is a bug");')
        os.append('')
    return '\n'.join(os)

